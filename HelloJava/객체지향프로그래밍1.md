# 객체지향 프로그래밍Ⅰ
## 클래스
### 객체지향적 관점
> 객체를 생성하기 위한 틀
- 속성과 기능으로 구성되어 있음  
  |구성 요소| 다른 이름| 
  |:--:|:--:|
  |속성|멤버변수(member variable), 특성(attribute), 필드(field),상태(state)| 
  |기능|메서드(method), 함수(function), 행위(behavior)|
### 프로그래밍적 관점
> 데이터와 함수의 결합
- 변수와 함수가 유기적으로 연결됨
- 예) C: 문자열=문자의 배열 / Java: 문자열=String 클래스
> 사용자 정의 타입(User-defined Type)
- 기본형 타입은 8개. 그 외 참조형은 프로그래머가 추가할 수 있음
- 타입을 정의하면서 제약조건을 설정할 수 있음

<br>

------  

```Java
class Variables{
  int iv;         // 인스턴스변수
  static int cv;  //클래스변수

  void method(){  // 메서드
    int lv = 0;   // 지역변수
  }
}
```
## 변수
|변수의 종류|선언위치|생성시기|특징|
|:--------:|:-------:|:------:|:----|
|클래스변수|클래스 영역|클래스가 메모리에 올라갈 때|`static`, 전역변수의 성격|
|인스턴스변수|클래스 영역|인스턴스가 생성되었을 때|인스턴스 생성 필요|
|지역변수|클래스 영역 이외의 영역|변수 선언문이 수행되었을 때|선언된 블럭을 벗어나면 소멸됨|
### 🤔 클래스변수와 인스턴스 변수
1. 클래스 변수
   - `static`을 붙여 선언하며, `[클래스이름].[변수이름]` 형태로 사용함
   - 모든 인스턴스가 공통된 저장공간을 공유함
   - 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야 하는 속성
   - 인스턴스를 생성하지 않고도 사용할 수 있음
2. 인스턴스 변수
   - 인스턴스 생성이 선행되어야 함
   - 인스턴스마다 독립적인 공간을 사용함
```Java
  class Car{
    int gasMileage; // 연비
    String color;   // 색상

    static int wheel = 4; // 바퀴 수
  }
```
<br>

## 메서드
> 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것. ***함수!***
### 🤔 메서드를 사용하는 이유
1. 재사용성이 높음(Reusability)
2. 중복된 코드의 제거
3. 프로그램의 구조화
### 메서드의 선언과 구현
```Java
반환타입 메서드이름 (타입 변수명, 타입 변수명)  // 선언부
{
  // 메서드 호출시 수행될 코드
}                                           // 구현부
```
### 메서드의 호출
#### 인자와 매개변수
- 인자(argument,인수): 메서드를 호출할 때 넘겨주는 **값**
- 매개변수(parameter): 메서드로 인자를 전달해주는 **변수**
- *argument는 값, parameter는 변수*
#### 매개변수의 유효성 검사
✅ ***매개변수의 값이 적절한 것인지 확인하자.***
- 적절하지 않은 값이 매개변수로 들어왔을 때?
  - 값을 보정함
  - `return`으로 작업 중단하고 호출한 메서드로 돌아감

### 클래스 메서드(static 메서드)와 인스턴스 메서드
​
| 메서드 종류 | 설명 | 특징 |
| --- | --- | --- |
| **클래스 메서드**   (=static 메서드) | 인스턴스와 관계없는 메서드   인스턴스 변수나 인스턴스 메서드를 사용하지 않음 | **static**, 인스턴스 메서드에 비해 호출 시간이 짧음 |
| **인스턴스 메서드** | 인스턴스 변수와 관련된 작업을 하는 메서드   메서드의 작업을 수행하는 데 인스턴스 변수를 사용함 | 인스턴스를 생성이 선행되어야 함 |
​


## 🖐 변수와 메서드 유의할 점
-   클래스를 설계할 때 멤버 변수 중 모든 인스턴스에 공통적으로 사용하는 것에는 static을 붙인다.
-   클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
-   클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
    -   같은 클래스 내에서 클래스 멤버가 인스턴스 멤버를 참조·호출해야 하는 경우 인스턴스 메서드로 작성해야 할 메서드를 클래스 메서드로 작성한 것은 아닌지 점검해야 한다.
-   메서드 내에서 인스턴스 변수를 사용하지 않으면 static을 붙이는 것을 고려한다. → 성능 향상

<br>
<br>

-----
## 오버로딩(Overloading)

> 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것  
> 같은 일을 하지만 매개변수가 달라야 할 때 구현한다.

오버로딩을 하기 위해서는 **메서드 이름은 같고 매개변수 타입이나 개수**(또는 순서)**가 달라야 한다**. 

<br>

#### 🤔 오버로딩이 되지 않는 경우 = 컴파일에러 발생!

-   매개변수의 타입과 개수가 모두 같고 매개변수의 이름만 다른 경우

    ```
    int add(int a, int b) { return a+b; }
    int add(int x, int y) { return x+y; }
    ```

-   매개변수의 타입과 개수가 모두 같고 반환 타입만 다른 경우 

    ```
    int add(int x, int y) { return x+y; }
    long add(int x, int y) { return (long)(x+y); }
    ```


<br>

#### 😮 의외로 오버로딩이 되는 경우

-   매개변수 개수와 타입 구성은 같은데 매개변수 선언 순서가 다른 경우

    ```
    long add(int x, long y) { return x+y; }
    long add(long x, int y) { return x+y; }
    ```
이렇게 매개변수 선언 순서만 다르게 오버로딩을 하는 경우 아래와 같은 장단점이 있다.
- 장점: 사용자가 매개변수의 순서를 외우지 않아도 된다.
- 단점: Java에서는 메서드를 호출할 때 매개변수와 동일한 타입의 인자뿐만 아니라 자동 형변환이 가능한 타입의 인자도 넘겨줄 수 있는데, 매개변수 선언 순서만 다르게 오버로딩하면 반드시 매개변수의 선언 타입과 동일한 타입의 인자만 넘겨줄 수 있다. 만약  `long x`에 `int`타입 값을 넘기면 둘 중 어느 메서드를 호출해야 할지 구별할 수 없어 컴파일에러가 발생한다.


### 오버로딩을 하는 이유

-   메서드 작성자는 메서드 이름을 짓는 데 고민을 덜 수 있다.
-   메서드 사용자는 메서드 이름을 일일이 외우지 않아도 된다.
-   메서드의 이름을 절약할 수 있다. 

_println 메서드가 오버로딩의 대표적인 예시이다._
<br>
<br>

---
## 가변인자(varargs)
> 메서드 매개변수의 개수를 동적으로 지정해주는 기능
### 선언 방법
- **`타입... 변수명`** 형식으로 선언한다.

    ```Java
    // PrintStream 클래스의 printf()
    public PrintStream printf(String format, Object... args)
    ```

- 가변인자 외 매개변수가 더 있다면 가변인자를 가장 마지막으로 선언해야 한다.

    ```Java
    // 가변인자가 다른 매개변수보다 먼저 선언되면 컴파일 에러가 발생한다.
    public PrintStream printf(Object... args, String format)
    ```
<br>

### 원리
1. 가변인자 메서드를 호출하면 인자의 개수와 길이가 같은 **배열이 자동으로 생성**됨
2. 그리고 인자들을 이 배열에 저장하여 가변인자 메서드에 넘겨줌
3. 메서드 안에서는 그 **배열을 통해** 넘어온 값들을 이용할 수 있음 

#### 🤔 배열 타입 매개변수와의 차이?
- 가변인자: 해당 매개변수로 넘어오는 인자가 없더라도 메서드를 이용할 수 있음 = **인자 생략 가능!**
- 배열 타입의 매개변수: null이든 길이가 0인 배열이든 인자를 지정해 주어야 함