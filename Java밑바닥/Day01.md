# ☕ Java 밑바닥 스터디 Day1
> 1. JVM, JRE, JDK 
> 2. Java 동작 원리
> 3. Garbage Collector 동작 원리
## JVM, JRE, JDK
> JVM, JRE, JDK는 자바 프로그램을 개발하고 실행하기 위한, 상호 연관된 컴포넌트  

![JDK, JRE, JVM](https://github.com/na-yk/conquer-java/assets/102007066/e01c1588-a338-4270-a72e-e20a87f184c5)
### JVM(Java Virtual Machine, 자바 가상 머신)
> 자바를 실행하기 위한 가상 기계(컴퓨터)
- 자바로 작성된 애플리케이션은 모두 JVM에서만 실행됨
- Java 애플리케이션과 운영체제 사이의 중개자 → Java 애플리케이션은 JVM과 운영체제를 거친 후 하드웨어로 전달됨
  - Java 애플리케이션: OS, HW 독립적(∵JVM과만 상호작용하기 때문)
  - 다른 OS에서 프로그램을 변경하지 않고도 실행할 수 있음
    - 단, JVM이 OS와 종속적 → OS마다 실행 가능한 JVM이 필요함 

### JRE(Java Runtime Environment, 자바 실행 환경)
> Java 애플리케이션을 실행하기 위해 필요한 최소 환경
> JVM + 클래스 라이브러리(Java API)
- JRE만 있으면 Java 애플리케이션을 실행할 수만 있고 개발할 수 없음
<details>
<summary>🐣 JRE에 포함된 Java API</summary>

- `java.lang`: Java 프로그래밍의 기본적인 클래스들을 포함
  - 예: `String`, `Object`, `Exception`  
- `java.util`: 유틸리티 클래스들을 포함  
  - 예: 컬렉션 프레임워크(`ArrayList`, `HashMap`), 날짜·시간 클래스(`Calendar`, `Date`), 랜덤 숫자 생성기(`Random`)
- `java.io`: 입출력 클래스 포함
  - 예: 파일(`File`), 입출력 스트림(`InputStream, `OutputStream`), 문자열(`Reader`, `Writer`)
- `java.net`: 네트워크 프로그래밍을 위한 클래스들을 포함
  - 예: 소켓 통신(`Socket`), URL 처리(`URL`), HTTP 통신
- `java.awt`, `javax.swing`: GUI 개발에 필요한 클래스들을 포함
- `java.sql`: 데이터베이스와 상호작용하기 위한 클래스들을 포함
  - JDBC를 사용하여 데이터베이스에 연결, 쿼리 실행하는 데 사용

</details>  
<br>

### JDK(Java Development Kit, 자바 개발 도구)
> Java 애플리케이션을 개발하는 데 사용되는 개발 도구
> JRE + 개발에 필요한 실행파일
#### JDK에 포함된 실행파일들
- javac: 자바 컴파일러 = 자바 소스코드를 바이트코드로 컴파일함
- java: 자바 인터프리터 = 컴파일러가 생성한 바이트코드를 해석하고 실행함
- javap: 역어셈블러 = 컴파일 된 클래스파일을 원래의 소스로 변환함
- javadoc: 자동문서생성기 = 소스파일에 있는 주석을 이용하여 Java API 문서와 같은 형식의 문서를 자동으로 생성함
- jar: 압축프로그램 = 클래스파일과 프로그램의 실행에 관련된 파일을 하나의 jar파일(`.jar`)로 압축하거나 압축 해제함

#### JDK LTS 버전 별 특징
*※ LTS(Long-Term Support): 출시 후 장기적으로 보안 패치와 버그 수정을 지원하는 버전*
##### JDK 8
- 람다와 스트림 도입: 함수형 프로그래밍 기능
- Java 컴파일러(javac)와 JVM의 성능 개선
- Date-Time API 개편→날짜·시간 처리 기능 강화
##### JDK 11
- 모듈시스템(Java Platform Module System, JPMS) 도입: 모듈화된 애플리케이션 개발을 위한 기능 제공
- HTTP 클라이언트 API 도입: 네트워크 통신을 위한 새로운 기능 제공
- G1GC 도입→기본 GC(Garbage Collector) 성능 향상
##### JDK 17
- `Switch`문 확장: 패턴 매칭과 새로운 문법 기능 제공
- ZGC(Zero Garbage Collector) 기능 개선→JVM 메모리 관리 개선
- 새로운 암호화 기능 및 알고리즘 추가
  - TLS 1.3 지원

<br>

---
## Java 동작 원리
### JVM 메모리 구조
> 1. Java 애플리케이션이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는 데 필요한 메모리를 할당 받음
> 2. JVM은 할당받은 메모리를 용도에 다라 여러 영역으로 나누어 관리함 

![JVM 메모리 구조](https://github.com/na-yk/conquer-java/assets/102007066/43cd1f19-7198-4678-9acb-79f8eae4ada3)  
#### 메서드 영역(method area)
> **프로그램 실행 중 클래스가 사용되었을 때** 클래스 데이터를 저장하는 공간
- JVM은 해당 클래스의 클래스파일(`.class`)을 읽어 분석하고 클래스 데이터를 메서드 영역에 저장함
   - 클래스변수(cv) 메서드 영역에 생성됨
#### 힙(heap)
> 프로그램 실행 중 인스턴스가 생성되는 공간
- 인스턴스 변수(iv)도 힙에 생성됨
#### 호출스택(call stack/execution stack)
> 메서드 작업에 필요한 메모리 공간을 제공
1. **메서드가 호출되었을 때** 메모리가 호출 스택에 할당됨
2. 호출 스택에 할당된 메모리는 메서드가 작업을 수행하는 동안 지역변수(lv), 매개변수, 연산의 중간결과를 저장함
3. 메서드 작업이 끝나면 할당되었던 사용한 메모리를 반환하고 스택에서 제거됨
4. 호출스택의 맨 위에 있는 메서드가 현재 실행 중인 메서드임
5. 아래의 메서드는 바로 위 메서드를 호출한 메서드임

### Java의 컴파일 과정
1. Java 컴파일러(javac)를 사용하여 소스코드를 컴파일한다.
   - 소스코드를 바이트코드로 변환함
     - 바이트코드: JVM에서 실행될 수 있는 중간 형식의 코드
   - 문법 오류 검사, 타입 체크 등 정적 분석 수행
2. 컴파일이 왼료되면 바이트코드가 `.class` 확장자를 가진 클래스 파일로 저장된다.
3. JVM이 컴파일된 클래스파일(`.class`)을 로드하고 클래스파일의 구조와 내용이 유효한 지 검증한다.
4. JVM이 로드된 클래스파일의 바이트코드를 해석하고 실행한다.
   - 바이트코드를 기계어로 번역하거나 인터프리터를 사용하여 바이트코드를 실행함
   - 최적화 작업을 통해 실행 속도를 개선할 수 있음

### 컴파일 언어vs인터프리터 언어
|    항목    | 컴파일 언어(Compiled Language)   |인터프리터 언어(Interpreted Language)|
|:--------:|:----------------------------|:-------|
| 소스 코드 변환 | 컴파일러에 의해 전체 소스 코드가 기계어로 변환됨 | 인터프리터에 의해 한 줄씩 해석됨          |
| 목적 코드 생성 | 생성됨                         | 생성되지 않음              |
| 실행 파일 생성 | 생성됨                         | 생성되지 않음              |
|   최적화    | 컴파일 단계에서 최적화 수행             | 실행 시간에 최적화 수행         |
|  실행 속도   | 빠름                          | 상대적으로 느림           |
| 수정 및 실행  | 수정 후 다시 컴파일해야 함             | 수정 후 즉시 실행 가능           |
|    예시    | C, C++, Java                | Python, JavaScript, Ruby    |

<br>

---
## Garbage Collector
> Java의 자동 메모리 관리 기법  
> JVM의 Heap 영역에서 동적으로 할당한 메모리 중 더 이상 필요없는 메모리 객체를 모아 주기적으로 제거하는 프로세스
> → 프로그래머가 따로 메모리를 관리하지 않아도 됨

### 방식
#### 1️⃣Reachability 판별
- root객체를 기준으로 도달 가능한 모든 객체를 식별함
  - Reachable: 객체가 참조되고 있는 상태
  - Unreachable: 객체가 참조되고 있지 않은 상태→GC의 대상이 됨
#### 2️⃣Mark&Sweep
##### Mark
1. Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아낸다.
2. 각각의 객체가 어떤 객체를 참조하고 있는지 찾아 마킹한다.
##### Sweep
1. 참조하고 있지 않은 객체(=unreachable)들을 Heap에서 제거한다.
2. Sweep 후 객체는 분산된다.
##### Compact(종류에 따라 하지 않기도 함)
1. Sweep 후 분산 된 객체들을 Heap의 시작 주소로 모은다.
2. 메모리가 할당된 부분과 할당되지 않은 부분으로 압축한다.

### 동작 원리
