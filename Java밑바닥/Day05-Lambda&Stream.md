# ☕Day5: 람다와 스트림(Lambda & Stream)
## 람다 Lambda
> 메소드를 클래스에 종속시키지 않고 식 하나로 표현함으로서 간략하고 명확하게 만들어줌  
- 이름과 반환값이 없어 **익명 함수**라고도 불린다.
- 람다식 자체가 메소드의 매개변수로 전달될 수도 있고, 메소드의 결과로 반환될 수도 있다.
- 람다식을 이용하면 객체를 생성하지 않고도 함수형 인터페이스를 간결하게 구현할 수 있다.
  - 이때 람다식 자체가 함수형 인터페이스의 구현체가 된다.
- 클래스에 종속되지 않는 메소드처럼 보이지만 람다식은 **익명 클래스의 객체**와 동등하다.
  - 인터페이스를 구현한 익명 객체를 람다식으로 대체할 수 있다.
  - 익명 클래스와 외부 변수 접근 규칙이 동일하다.
    - 람다식 내에서 참조하는 지역변수는 `final`을 붙이지 않아도 상수이다.

### 람다식 작성법
```java
반환타입 메소드이름 (매개변수 선언) {
    문장들
}
```
위의 메소드를 아래와 같은 람다식으로 작성할 수 있다.
```java
(매개변수 선언) -> {
    문장들
}
```
- 반환값이 있는 메서드를 람다식으로 표현하면 식의 연산결과가 자동적으로 반환값이 된다.
- 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략할 수 있다.
- 선언된 매개변수가 하나뿐이면 괄호를 생략할 수 있다.
- `{ }` 괄호 안 문장이 하나이면 괄호를 생략할 수 있다.
  - 문장의 끝에 `;`를 붙이지 않는다.
### 함수형 인터페이스 Functional Interface
> 단 하나의 추상 메소드를 가지는 람다식을 다루기 위한 인터페이스
- 추상 메소드는 **하나만** 가져야 한다.
    - 람다식과 인터페이스의 메소드가 일대일 연결될 수 있다.
    - 단, `static`메소드와 `default`메소드의 개수는 제약이 없다.
- `@FunctionalInterface` 어노테이션 으로 함수형 인터페이스를 명시적으로 선언할 수 있다.
- 함수형 인터페이스로 람다식을 참조할 수 있다.
  - 다만 람다식은 익명 객체라서 컴파일러가 임의로 타입을 정하기 때문에, 람다식의 타입이 인터페이스의 타입이 일치하지는 않는다.
  - **형변환**이 반드시 필요하다.
### `java.util.function`
> 자주 쓰이는 형식의 메소드를 함수형 인터페이스로 미리 정의해놓은 패키지
- `java.lang.Runnable`
- `Supplier<T>`
- `Consumer<T>`
- `Function<T>`
- `Predicate<T>`
---
## 스트림 Stream
> 데이터 처리를 위해 연산을 제공하는 연속된 요소의 흐름
### 🤔스트림 등장 배경
여러 데이터를 다룰 때 컬렉션이나 배열에 데이터를 담고 `for`문과 `Iterator`를 사용해왔다.
  - 코드가 길어지고 재사용성이 떨어짐
  - 데이터 소스마다 다른 방식으로 다뤄야함
    - `Collection`, `Iterator`같은 인터페이스로 컬렉션을 다루는 방식을 표준화하였으나, 각 컬렉션 클래스에 같은 기능의 메소드들이 중복 정의되어 있음
#### 스트림의 장점: 데이터소스의 추상화
  - 데이터 소스가 무엇이든 같은 방식으로 다룰 수 있음 → 코드의 재사용성↑
    - 배열, 컬렉션, 파일 데이터 등을 다 같은 방식으로 다룰 수 있음
### 스트림의 특징
#### 1️⃣데이터 소스를 변경하지 않음
- 데이터 소스로부터 데이터를 읽기만 한다.
- 필요하다면 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수 있다.
#### 2️⃣일회용
- 한 번 사용하면 닫혀서 다시 사용할 수 없으므로, 필요하면 스트림을 다시 생성해야 한다.
#### 3️⃣작업을 내부 반복으로 처리함
- 내부반복: 반복문을 메소드 내부에 숨김
- `forEach()`: 매개변수에 대입된 람다식을 데이터 소스의 모든 요소에 적용하는 스트림의 메소드
    ```java
        for(int index: indexList)
            System.out.println(index);
    ```
  
    ```java
        stream.forEach(System.out::println);
        stream.forEach((index)->System.out.println(index));
    ```
### 스트림의 연산: 중간 연산과 최종 연산
|내용|중간 연산|            최종 연산            |
|:----:|:-----:|:---------------------------:|
|연산 결과|스트림|           스트림이 아님           |
연속 연산|스트림에 연속해서 중간 연산 가능| 스트림의 요소를 소모하여 한 번만 연산할 수 있음 |
- 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다.
- `IntStream`,`LongStream`,`DoubleStream`
  - 기본적으로 스트림은 `Stream<T>`의 형태인데 이는 오토박싱과 언박싱으로 인해 비효율적이다.
  - 비효율을 줄이기 위해 데이터 소스 요소를 기본형으로 다루는 스트림을 제공한다.
- `parallel()` 메소드를 이용해서 병렬 연산을 수행할 수 있다.
