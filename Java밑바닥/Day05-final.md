# ☕Day5: final
> *"변경될 수 없는"*  

클래스, 메소드, 멤버변수, 지역변수에 사용될 수 있다.
각각에 제어자 `final`을 사용했을 때의 의미는 아래와 같다.

|   대상    | 의미                                                          |
|:-------:|:------------------------------------------------------------|
|클래스| 변경되거나 확장될 수 없는 클래스→**다른 클래스의 조상이 될 수 없음**                   |
|메소드| 변경될 수 없는 메소드                          →**오버라이딩을 통한 재정의 불가** |
|멤버변수| 값을 변경할 수 없는 **상수**|
|지역변수|값을 변경할 수 없는 **상수**|

### `final`멤버변수 초기화
- `final`이 붙은 상수는 보통 선언과 초기화를 동시에 한다. 
- 다만 인스턴스변수는 **생성자**에서 매개변수로 받은 값으로 초기화할 수 있다.
- 이를 이용하면 각 인스턴스들의 `final` 멤버변수가 다른 값을 가질 수 있다.


<br>

---
## Effectively final
> `final`이 붙지 않았는데 초기화 이후 값이 변경되지 않는 변수

### 🤔어떻게 유용한가?
주로 람다식이나 익명 클래스에서 코드를 간결하게 만든다.
#### 익명 클래스(Anonymous Class)
- 익명클래스는 외부의 변수가 `final`일 때만 접근할 수 있다.
- 초기화 이후 값이 변경되지 않는 변수는 `final` 변수로 취급하므로 익명 클래스에서 해당 변수에도 접근할 수 있게 된다.
#### 람다식
- 람다식에서 지역변수에 값을 재할당하면 안 된다.
  - 컴파일에러 발생: `java: local variables referenced from a lambda expression must be final or effectively final`
- 람다식에서 사용되는 외부 지역 변수는 복사본이다.
  - 왜냐하면?
    - 지역변수는 **스택 영역**에 생성되므로, 지역변수가 선언된 블럭이 끝나면 스택에서 제거되어 추후에 람다식이 수행될 때 참조할 수 없다.
    - 지역변수를 관리하는 thread와 람다식이 실행되는 thread가 다를 수 있는데, 스택은 thread 고유의 공간이고 thread끼리 공유되지 않는다.
    - thread별로 스택이 다르므로 thread 간 지역변수를 공유할 수 없기 때문에 갑이 보장되지 않는다.
- 복사본이 변경되지 않은 최신값임을 보장하기 위해 `final` 또는 `effectively final`이어야 한다.