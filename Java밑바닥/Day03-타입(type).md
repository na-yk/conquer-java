# ☕Day3: 타입(type)
> **자료형(data type)이란?**  
> 값이 저장될 공간의 크기와 저장형식을 정의한 것
## 기본형과 참조형
|  항목   | 기본형(primitive type)                                                      | 참조형(reference type)              |
|:-----:|:------------------------------------------------------|:---------------------------------|
|  저장   | 실제 값(data)                                                               | 어떤 값이 저장되어 있는 주소(memory address) |
|  종류   | 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double) |8개의 기본형을 제외한 나머지 타입|

### 기본형(primitive type)
- 계산을 위한 실제 값을 저장하는 type
- 총 8개
  - 논리형: `boolean`
    - 다른 기본형과 연산할 수 없음
  - 문자형: `char`
  - 정수형: `byte`, `short`, `int`, `long`
    - `int`는 일반적으로 CPU가 가장 효율적으로 처리할 수 있는 type임
  - 실수형: `float`, `double`

### 참조형(reference type)
- 객체의 주소를 저장하는 type→기본형 8개를 제외한 나머지
  - `String`은 참조형 타입
    - 다만 예외적으로 `new`를 사용하지 않고도 문자열 리터럴을 생성할 수 있음 
    - 기본형, 참조형의 구별 없이 어떤 타입의 변수이든 문자열과 덧셈 연산을 수행하면 그 결과가 문자열이 됨
- 참조형 변수를 선언할 때
  - `[클래스이름] [변수이름]`
  - 클래스 이름을 변수의 타입으로 사용 → 클래스의 이름=참조변수의 타입
  - 새로운 클래스를 작성하는 것은 새로운 참조형을 추가하는 것과 같음
  - Heap 영역에 메모리가 할당되고, 그 주소가 변수에 저장되는 것!

## Call by Value vs Call by Reference
|      내용      | Call by Value(값에 의한 호출)              | Call by Reference(참조에 의한 호출)             |
|:------------:|:-------------------------------------|:-----------------------------------------|
|      의미      | 함수에 인자로 전달되는 변수의 **값**만 복사하여 전달하는 방식 | 함수에 인자로 전달되는 변수의 메모리 **주소(참조)**를 전달하는 방식 |
| 인자와 매개변수의 관계 | 인자와 매개변수가 서로 다른 메모리 공간을 이용           | 인자와 매개변수가 같은 메모리 공간을 이용                  |
|  메서드 실행 결과   | 전달받은 값을 변경해도 인자의 원본 값이 바뀌지 않음        | 전잘 받은 값을 변경하면 인자의 원본 값도 바뀜               |


### Java는 Call by Value? Call by Reference?
> Java는 **Call by Value** 방식을 따른다!
#### 🤔 객체를 전달받았을 때 원본도 바뀌는데?
- 참조형 타입은 Heap Memory 영역에 생성된 객체의 주소값을 참조함
- 즉, 참조 변수는 애초에 객체의 주소를 저장하고 있기 때문에 참조 변수의 값을 전달할 때 주소의 복사본을 전달하는 것
- 따라서 참조 변수를 인자를 넘길 때 원본값이 변경되지 않도록 하려면 호출한 메서드에서 넘겨받은 값으로 새로운 객체를 생성하여 작업을 수행해야 함


## 래퍼 클래스(Wrapper Class)
> 기본형(primitive type) 변수를 객체로 다루고 싶을 때 기본형 값을 객체로 감싸주는 클래스

|    기본형    | Wrapper Class | 생성자                                           |
|:---------:|:-------------:|:----------------------------------------------|
| `boolean` |   `Boolean`   | `Boolean(boolean value)`, `Boolean(String s)` |
|  `char`   |  `Character`  | `Character(char value)`                       |
|  `byte`   |    `Byte`     | `Byte(byte value)`, `Byte(String s)`          |
|  `short`  |    `Short`    | `Short(short value)`, `Short(String s)`       |
|   `int`   |   `Integer`   | `Integer(int value)`, `Integer(String s)`     |
|  `long`   |    `Long`     | `Long(long value)`, `Long(String s)`          |
|  `float`  |    `Float`    | `Float(float value)`, `Float(String s)`       |
| `double`  |   `Double`    | `Double(double value)`, `Double(String s)`    |

### Wrapper class를 사용하는 경우
- 제네릭(Generic) 사용: 제네릭을 사용하는 경우, 기본 타입을 사용할 수 없기 때문에 wrapper class를 사용해서 제네릭에 기본 타입을 전달할 수 있움
- 컬렉션(Collection)에 기본 타입 저장: 컬렉션은 객체만 저장할 수 있기 때문에 기본 타입을 저장하려면 wrapper class를 사용해야 함
- 기본 타입과 관련된 유틸리티 메서드 사용: wrapper class가 제공하는 기본 타입 관련 유틸리티 메서드를 사용할 수 있음
  - 예) `Integer` 클래스: 숫자 변환, 비트 연산 등
- Null 값 처리: 기본 타입은 null 값을 가질 수 없지만 wrapper 클래스는 null을 허용함


<br>

---
## 제네릭(Generic)
> 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능  
### 제네릭을 사용하는 이유
#### 타입 안정성
> 객체의 타입을 컴파일 시에 체크함으로써 객체의 타입 안정성을 높임
- 의도하지 않은 타입의 객체가 저장되는 것을 방지
- 저장된 객체를 꺼내올 때 원래의 타입과 다른 타입으로 잘못 형변환되어 발생할 수 있는 오류를 줄임
#### 타입 체크와 형변환 생략 → 코드 간결성
- 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있으나, 일반적으로 한 종류의 객체를 담음
  - 이 때 객체를 꺼낼 때마다 타입체크를 하고 형변환을 하지 않도록 해줌
  - 원하지 않는 종류의 객체가 포함되지 않도록 해줌
### 제네릭 클래스의 선언
- 제네릭 타입은 클래스의 메서드에 선언함


<br>

---
## 추가할 내용  
- [ ] `Auto-boxing`에 대해 찾아보기
- [ ] `Generic` 내용 추가
- 